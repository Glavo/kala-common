# Kala Common Tutorial

Table of contents:

* [Use Kala Collection](#use-kala-collection) (WIP)
* Use Kala Collection for primitive types (WIP)
* [Use reverse indexes in Kala Common](#use-reverse-indexes-in-kala-common)
* ... (WIP)

## Use Kala Collection

### Overview

Kala Collection provides the following common collection interfaces:

* `Traversable`: An Iterable with more functionality.
  * `Collection`: Common interface implemented by collections.
    * `Seq`: An ordered collection of values that can be accessed by integer index.
    * `Set`: A collection that contains no duplicate elements.
      * `SortedSet`: A `Set` that further provides a total ordering on its elements.
* `Map`: An object that maps keys to values.

These collections have immutable and mutable variants.
For example, for `Seq`, it has the following important subinterfaces:

* `Seq`
  * `ImmutableSeq`: An immutable seq. The user cannot modify it, but can generate another seq from an existing seq.
  * `MutableSeq`: A mutable seq. It is similar to an array in that the user can modify this seq, but it does not provide methods that would change the size of the seq.
    * `MutableList`: It is a better alternative to `java.util.List` and provides more useful methods.

This is a diagram of the basic collection types:

Basic:
```mermaid
graph TD;
    Sized --> Traversable;
    Sized --> Map;
    Traversable --> Collection;
    Collection --> Seq;
    Collection --> Set;
    Set --> SortedSet;

    Seq ---> ArraySeq;

    Map --> SortedMap;

    classDef impl fill: #90EE90, stroke: #fff, stroke-width: 4px;
    class ArraySeq impl;
```

Immutable Collections:
```mermaid
graph TD;
    Seq --> ImmutableSeq;
    ImmutableCollection --> ImmutableSeq;
    Set --> ImmutableSet;
    ImmutableCollection --> ImmutableSet;
    ImmutableSet --> ImmutableSortedSet;
    
    ImmutableSeq --> ImmutableArray;
    ImmutableSeq --> ImmutableVector;
    ImmutableSeq --> ImmutableLinkedSeq;
    ImmutableSeq --> ImmutableTreeSeq;
    ImmutableSortedSet ---> ImmutableSortedArraySet;
    ImmutableSet ----> ImmutableHashSet;
    ArraySeq --> ImmutableArray;

    classDef impl fill: #90EE90, stroke: #fff, stroke-width: 4px;
    class ArraySeq,ImmutableArray,ImmutableVector,ImmutableHashSet,ImmutableSortedArraySet,ImmutableLinkedSeq,ImmutableTreeSeq impl;
```

Mutable Collections:

```mermaid
graph TD;
  Seq --> MutableSeq;
  MutableCollection --> MutableSeq;
  MutableSeq --> MutableList;
  Set --> MutableSet;
  MutableCollection --> MutableSet;
  MutableSet --> MutableSortedSet;
  
  MutableSeq ---> MutableArray;
  MutableList --> MutableArrayList;
  MutableList --> MutableArrayDeque;
  MutableList --> MutableSmartArrayList;
  MutableList --> MutableLinkedList;
  MutableList --> MutableSinglyLinkedList;
  ArraySeq --> MutableArray;
  MutableSet ---> MutableEnumSet;
  MutableSet ---> MutableHashSet;
  MutableSortedSet --> MutableTreeSet;
  
  
  classDef impl fill: #90EE90, stroke: #fff, stroke-width: 4px;
  class ArraySeq,MutableArray,MutableArrayList,MutableArrayDeque,MutableSmartArrayList,MutableLinkedList,MutableSinglyLinkedList,MutableEnumSet,MutableHashSet,MutableTreeSet impl;
```

### Creating collections using factory methods

Most collection interfaces and implementation classes provide a series of convenient static factory methods
for creating collections.

```java
// Create a collection from values
var _ = Seq.of(1, 2, 3); // ==> [1, 2, 3]

// Create a collection from array
var _ = Seq.from(new Integer[] {1, 2, 3});  // ==> [1, 2, 3]

// Create a collection from any iterable object
var _ = Seq.from(java.util.List.of(1, 2, 3));  // ==> [1, 2, 3]

// Create a collection from an iterator
var _ = Seq.from(java.util.List.of(1, 2, 3).iterator());  // ==> [1, 2, 3]

// Create a collection from a stream
var _ = Seq.from(java.util.stream.Stream.of(1, 2, 3));  // ==> [1, 2, 3]

// Create a seq filled with N identical values
var _ = Seq.fill(3, "value"); // ===> ["value", "value", "value"]

// Create a seq of N values, each of which is generated by a user-supplied function
var _ = Seq.fill(3, i -> i + 10); // ===> [10, 11, 12]

// Wrap an existing java.util.List as a Seq (without copying)
var _ = Seq.wrapJava(List.of(1, 2, 3)); // ===> [1, 2, 3]
```

In addition, each collection class/interface provides a static `factory()` method 
to get a `CollectionFactory` corresponding to a collection.
The `CollectionFactory` instance also provides factory methods similar to the above and can be used as a `java.util.stream.Collector`.

```java
var _ = Seq.<Integer>factory().of(1, 2, 3); // ===> [1, 2, 3]

// Use as Collector
var _ = Stream.of(1, 2, 3).collect(Seq.factory()); // ===> [1, 2, 3]
```

More usage of `CollectionFactory` will be introduced in later chapters.

### `Traversable`

Interface `Traversable` inherits from `java.lang.Iterable`.
Based on `Iterable`, `Traversable` provides a lot of useful methods.

#### `spliterator()`, `stream()` and `parallelStream()`

`Traversable` provides `spliterator()`, `stream()` and `parallelStream()` similar to [`java.util.Collection`](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Collection.html).
Therefore, all collections in Kala Collection can work well with Java Stream.

(WIP)

## Use reverse indexes in Kala Common

There are many APIs in Kala Common that accept integer indexes, such as `Seq::get(int)`.

> [!NOTE]
> Currently all of these indexes are of type `int`, and we are planning to migrate them all to `long`.
> See [#77](https://github.com/Glavo/kala-common/issues/77) for more details.

Unlike most Java libraries, most of the Kala Common API accepts reverse indexes.
These parameters are marked with `@kala.index.Index`.

When the API receives a negative index `idx`, it calculates the actual index like this:

```java
int actualIdx = size() - ~idx;
```

Here are some examples using reverse indexes:

```java
var seq = Seq.of(1, 2, 3);

// Get the last element
var _ = seq.get(~1); // ===> 3

// Get a slice of Seq except the first element
var _ = seq.slice(1, ~0); // ===> [2, 3]

// Get a slice of Seq except the last element
var _ = seq.slice(0, ~1); // ===> [1, 2]
```

It is worth noting that Kala Common differs slightly from Python's List
in that it uses the `~` (Bitwise Complement Operator) to indicate reverse indexes.
This option has two significant advantages:

* We can use the `~0` to indicate the end of the seq;
* Some methods (such as `indexOf`) return `-1` for invalid indexes.
  If some APIs accepted `-1` as a valid index, it might confuse users.
  But `-1` is equal to `~0`, so there is no such confusion in Kala Common. 
  On the contrary, we can use this to simplify some code.
  For example:
  ```java
  StringSlice getKey(StringSlice value) {
      return StringSlice.of(value, 0, value.indexOf('=')).trim();
  }
  
  var _ = getKey("i"); // ===> "i"
  var _ = getPrefix("i = 10"); // ===> "i"
  ```